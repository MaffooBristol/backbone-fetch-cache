{"name":"Backbone-fetch-cache","tagline":"Caching for Backbone's fetch method","body":"# Backbone fetch cache\r\n\r\n[![Build Status](https://travis-ci.org/madglory/backbone-fetch-cache.png?branch=master)](https://travis-ci.org/madglory/backbone-fetch-cache)\r\n\r\nA Backbone plugin to cache calls to `Backbone.Model.prototype.fetch` and\r\n`Backbone.Collection.prototype.fetch` in memory and `localStorage`.\r\n\r\nCompatible with Backbone 1.0.0 and up.\r\n\r\n## How it works\r\nThis plugin intercepts calls to `fetch` and stores the results in a cache object (`Backbone.fetchCache._cache`). If fetch is called with `{ cache: true }` in the options and the URL has already been cached the AJAX call will be skipped.\r\n\r\nThe local cache is persisted in `localStorage` if available for faster initial page loads.\r\n\r\nThe `prefill` option allows for models and collections to be filled with cache data just until the `fetch` operations are complete -- a nice way to make the app feel snappy on slower connections.\r\n\r\n## What's wrong with browser caching for AJAX responses?\r\nNothing. This plugin is primarily for working with an API where you don't have control over response cache headers.\r\n\r\n## Usage\r\nAdd the script to the page after backbone.js has been included:\r\n\r\n```html\r\n<script src=\"/path/to/backbone.js\"></script>\r\n<script src=\"/path/to/backbone.fetch-cache.js\"></script>\r\n```\r\n\r\nor if you're using AMD, require the script as a module:\r\n\r\n```js\r\nrequire(['path/to/backbone.fetch-cache.js']);\r\n```\r\n\r\nNote that the AMD module depends on `underscore` and `backbone` modules being defined as it lists them as dependencies. If you don't have these mapped, you can do it by adding the following to your require config:\r\n\r\n```js\r\nrequirejs.config({\r\n  paths: {\r\n    backbone: 'actual/path/to/backbone.js',\r\n    underscore: 'actual/path/to/underscore.js'\r\n  }\r\n});\r\n```\r\n\r\nA note on [Zepto.js](http://zeptojs.com/). This plugin uses `jQuery.Deferred`\r\nwhich is not included in Zepto. You'll need to add a third party\r\nimplementation of `jQuery.Deferred`, e.g. [Standalone-Deferred](https://github.com/Mumakil/Standalone-Deferred)\r\n\r\n## Options\r\n### `cache`\r\nCalls to `modelInstance.fetch` or `collectionInstance.fetch` will be fulfilled from the cache (if possible) when `cache: true` is set in the options hash:\r\n\r\n```js\r\nmyModel.fetch({ cache: true });\r\nmyCollection.fetch({ cache: true });\r\n```\r\n\r\n<hr />\r\n\r\n### `prefill`\r\nThis option allows the model/collection to be populated from the cache immediately and then be updated once the call to `fetch` has completed. The initial cache hit calls the `prefillSuccess` callback and then the AJAX success/error callbacks are called as normal when the request is complete. This allows the page to render something immediately and then update it after the request completes. (Note: the `prefillSuccess` callback _will not fire_ if the data is not found in the cache.)\r\n\r\n```js\r\nmyModel.fetch({\r\n  prefill: true,\r\n  prefillSuccess: someCallback, // Fires when the cache hit happens\r\n  success: anotherCallback // Fires after the AJAX call\r\n});\r\n\r\nmyCollection.fetch({\r\n  prefill: true,\r\n  prefillSuccess: someCallback, // Fires when the cache hit happens\r\n  success: anotherCallback // Fires after the AJAX call\r\n});\r\n```\r\n\r\nThis option can be used with the promises interface like so (note: the `progress` event _will not fire_ if the data is not found in the cache.):\r\n\r\n```js\r\nvar modelPromise = myModel.fetch({ prefill: true });\r\nmodelPromise.progress(someCallback); // Fires when the cache hit happens\r\nmodelPromise.done(anotherCallback); // Fires after the AJAX call\r\n\r\nvar collectionPromise = myModel.fetch({ prefill: true });\r\ncollectionPromise.progress(someCallback); // Fires when the cache hit happens\r\ncollectionPromise.done(anotherCallback); // Fires after the AJAX call\r\n```\r\n\r\n<hr />\r\n\r\n### `expires`\r\n\r\nCache vales expire after 5 minutes by default. You can adjust this by passing\r\n`expires: <seconds>` to the fetch call. Set to `false` to never expire:\r\n\r\n```js\r\nmyModel.fetch({ cache: true, expires: 60000 });\r\nmyCollection.fetch({ cache: true, expires: 60000 });\r\n\r\n// These will never expire\r\nmyModel.fetch({ cache: true, expires: false });\r\nmyCollection.fetch({ cache: true, expires: false });\r\n```\r\n\r\n<hr />\r\n\r\n### `localStorage`\r\nBy default the cache is persisted in localStorage (if available). Set `Backbone.fetchCache.localStorage = false` to disable this:\r\n\r\n```js\r\nBackbone.fetchCache.localStorage = false;\r\n```\r\n\r\n### Custom cache keys\r\n\r\nBy default the cache key is generated from the model's `url` property and the requests params:\r\n\r\n```js\r\n'/model/1?some=param'\r\n```\r\n\r\nThis can be overridden with custom logic if required:\r\n\r\n```js\r\n// Instance is a Backbone.Model or Backbone.Collection, options are passed\r\n// through form the fetch call\r\nBackbone.fetchCache.getCacheKey = function(instance, options) {\r\n  return instance.constructor.name + ':' + instance.get('id');\r\n  // => UserModel:1\r\n};\r\n```\r\n\r\n### `priorityFn`\r\nWhen setting items in localStorage, the browser may throw a ```QUOTA_EXCEEDED_ERR```, meaning the store is full. Backbone.fetchCache tries to work around this problem by deleting what it considers the most stale item to make space for the new data. The staleness of data is determined by the sorting function ```priorityFn````, which by default returns the oldest item.\r\n\r\nThe default is:\r\n```\r\nBackbone.fetchCache.priorityFn = function(a, b) {\r\n  if (!a || !a.expires || !b || !b.expires) {\r\n    return a;\r\n  }\r\n\r\n  return a.expires - b.expires;\r\n};\r\n```\r\n\r\nYou can override this function with your own logic (in this case, returning the most recent item):\r\n```\r\nBackbone.fetchCache.priorityFn = function(a, b) {\r\n  return b.expires - a.expires;\r\n};\r\n```\r\n\r\n## Events\r\n\r\nThe `sync` event is triggered on a cache hit. A `cachesync` event is also triggered on Models and Collections, but only when a cache hit happens. This can be used if you need to differentiate between a server backed `sync` event and a cache backed event.\r\n\r\n## Automatic cache invalidation\r\nThe cache item for a particular call will be cleared when a `create`, `update`, `patch` or `delete` call is made to the server. The plugin tries to be intelligent about this by clearing a model's collection cache if the model has a `.collection property`.\r\n\r\nTo achieve this, the plugin overrides `Backbone.Model.protoype.sync` and then calls the original method. If you are planning to override sync on a particular model then you should keep this in mind and make sure that you do it before the plugin runs. Overriding Backbone.sync directly should work fine.\r\n\r\n## Manual cache invalidation\r\nSometimes you just need to clear a cached item manually. This can be called safely from anywhere in your application.\r\n\r\n```js\r\nBackbone.fetchCache.clearItem(myModel.url);\r\n```\r\n\r\n## Tests\r\nYou can run the tests by cloning the repo, installing the dependencies and\r\nrunning `grunt jasmine`:\r\n\r\n```\r\n$ npm install\r\n$ grunt jasmine\r\n```\r\n\r\nThe default grunt task runs tests and lints the code.\r\n\r\n```\r\n$ grunt\r\n```\r\n\r\n## Releases\r\nWe will handle release versioning based on the changes. This will update `package.json`, `bower.json`, and also create a new git tag. See [grunt-bump](https://github.com/vojtajina/grunt-bump) for more documentation.\r\n\r\n```\r\n$ grunt bump:patch\r\n$ grunt bump:minor\r\n$ grunt bump:major\r\n```\r\n\r\nOnce the version is bumped you can uglify the file so the version makes it into the uglified version.\r\n\r\n```\r\n$ grunt uglify\r\n```\r\n\r\nNow commit the changes, push to GitHub, and `npm publish`.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}